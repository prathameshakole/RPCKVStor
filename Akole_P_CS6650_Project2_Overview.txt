Project 2: Overview and Technical Impression




The main focus of this project was to build on our previous key-value store by implementing RPC communication and adding multi-threading capabilities. While Project 1 focused on fundamental client-server communication, this project pushed us to think about scalability and concurrent operations. This project helped me connect theoretical knowledge from lectures and challenges with practical implementation in distributed systems. Using the RMI Registry for service discovery helped me understand how distributed components find and communicate with each other in a distributed environment. The project highlighted the importance of proper interface design and remote exception handling, which are very important aspects of distributed system development. This project also introduced important concepts of middleware technology like RMI, demonstrating how modern distributed systems can abstract complex details while providing robust communication channels between different components. The project also highlighted the evolution in distributed system design, which showed us how RMI can simplify network programming compared to direct socket programming. I also got to learn about multi-threading, mutual exclusion concepts which helped further in the project to make important decisions regarding the project.


Though the implementation turned out to be easy, the technical aspects of implementation presented several challenges. Firstly, Setting up the RMI architecture required me to carefully understand how to properly structure the remote interfaces, implement them, and handle remote exceptions. Next, I struggled with the Registry setup and understanding the sequence of starting the registry, server, and client. For thread safety, I used ConcurrentHashMap as the data structure for the key-value store that provided thread-safe operations. I also used synchronized method signatures for the PUT, GET, and DELETE operations to ensure the atomic execution of these methods. The synchronized methods made sure that only one thread could execute one operation at a time, maintaining the consistency of the data while still allowing concurrent access to different methods.


This project provided practical exposure to both distributed systems and concurrent programming concepts. Working with RMI taught me how Java abstracts away the complexity of network communication while implementing multi-threading showing the importance of choosing appropriate thread-safe data structures. The practical understanding gained about RPC and multi-threading is very important as it directly applies to modern software development, where concurrent programming is increasingly common. The use of ConcurrentHashMap demonstrated how modern Java collections can simplify concurrent programming by providing built-in thread safety. Looking back, while the project was challenging, it provided very important hands-on experience with concepts that are pivotal in modern distributed system design.